\chapter{Engineering the Liquid Citizen Platform}
\label{ch:ProjectRequirements}
This chapter will distill the efforts of all the previous chapters leading to the concrete design of a citizen science-enabled liquid 
democracy platform from a software engineering perspective.
Based on the \hyperref[ch:Approach]{discussion of the approach} in \autoref{ch:Approach}, to fulfill the objective of this project, and due to the fact that no suitable software exists to base the project on, this section will document the initial software engineering process upon which can be built in order to realize a platform that meets the derived \hyperref[sec:Criteria]{criteria} for a \tracknshrink{CS}-enabled \tracknshrink{LD} platform.

Therefore, we start by explicitly documenting the \hyperref[sec:SoftwareRequirements]{software requirements} which we derive from the previous chapters.
We then continue by laying the foundation for a more technical view of the platform by discussing possibilities of its \hyperref[sec:ArchitecturalDesign]{architectural design} before we go into detail on the available options concerning the \hyperref[sec:ApplicationDesign]{application design} in the exemplary setting of a microservices architecture and a local client.
The chapter is then concluded by the specification of two protocols, namely the \hyperref[sec:PublicDeclarationOfIntentProtocol]{public declaration of intent protocol} and the \hyperref[sec:VoteTallyingProtocol]{vote tallying protocol}, that revolve around vote, support and delegation intents posted in the public space.


% narrative: discuss architectural design -> choose microservices
% how to name the section on the actual microservices implementations?



%we will \hyperref[sec:SoftwareRequirements]{derive software requirements} the prototype needs to fulfill, before describing the \hyperref[sec:Implementation]{process of implementing} said prototype.
%Since we base our prototype on a modular architecture around microservices, we will focus predominantly on the \hyperref[ssec:Architecture]{architecture} of the prototype, as well as a detailed description of the implemented \hyperref[ssec:Microservices]{micro services}.
%Then, we define two protocols, namely the \hyperref[sec:PublicDeclarationOfIntentProtocoll]{public interaction protocol} and the \hyperref[sec:VoteTallyingProtocol]{vote tallying protocol}, that revolve around vote and delegation intents in the public space.
%Finally, we present the \hyperref[ssec:DemoApplication]{demo application} that showcases the integration of all the previously introduced parts of the platform.
\section{Software Requirements}
\label{sec:SoftwareRequirements}

Every software engineering process begins with a requirements analysis whose execution will differ considerably depending on which software engineering methodology is being used.
The goal of all requirements analysis processes is to identify the requirements towards the envisioned software product from a variety of different angles, i.e. how is the software used by different user roles, how should it interface with existing software, which of these are functional requirements and which are non-functional.

For the sake of brevity and to increase the agility of potential developers of the platform, we chose to follow the scrum methodologies approach to requirements analysis.
In the scrum method, requirements are formulated as so called user stories.
A user story is a statement of the form "As X I want Y (in order to [reach a Z])."), where X is a user role, Y is the detailed description of an activity the given role should be able to perform with the envisioned final software product and Z is the goal the user wants to reach.
In the scrum methodology, user stories are then broken down into tasks which are assigned to contributors / developers in scrum sprints.

However, we are aiming for an abstract albeit accurate documentation of the Liquid Citizen platform's requirements, not for a step-by-step manual, which we could not provide anyway without the knowledge of final decisions in the compartments of architecture, languages and frameworks used.
To this end, we will now record all requirements that can be extracted from our previous discussion in chapters~\ref{ch:Theory}~and~\ref{ch:Approach} as user stories.
We have assigned a priority score between one and ten to each user story. Stories scoring 10 are absolutely necessary for the simplest of prototypes, while those on the other end of the spectrum are not necessary for the core functionality at all and could potentially be delivered as updates even after the platform is already used in production.

\userstory{10}
As a \textit{user} I want to initiate a proposition in order start the political process in a certain context of my interest, thereby becoming the \textit{proposition author} of the newly initiated proposition.

\userstory{10}
As a \textit{user} and potential \textit{vote accumulator} I want to vote on a proposition in the voting phase.

\userstory{10}
As a \textit{user} I want to delegate my vote to someone else, becoming a \textit{vote delegator} and making that someone a \textit{vote accumulator}.

\userstory{9}
As a \textit{user} I want to support a proposition group in order to propel it to the discussion phase, thereby becoming \textit{proposition group supporter}.

\userstory{9}
 As a \textit{user} I want support a proposition in a discussion phase in order to propel it to the voting phase, thereby becoming a \textit{proposition supporter}.

\userstory{9}
 As a \textit{user} I want to create a discussion entry on a proposition or change request, thereby becoming a \textit{discussion participant} and a \textit{proposition follower}.

\userstory{9}
 As a \textit{proposition author}, I want to modify the contents of my proposition.

\userstory{9}
 As a \textit{user} I want to edit my context subscriptions in my profile, becoming a \textit{context follower} of each context subscribed to.

\userstory{9}
 As an \textit{admin} I want to delete \textit{users}.

\userstory{8}
 As a \textit{user} I want to change my profile data (change password, mail, political affiliations such as party membership) in order to reflect my current my political profile.
 
 \userstory{8}
 As a \textit{user} I want to create an alternative proposition on an existing proposition, putting it in the original propositions proposition group and inheriting its primary context, thereby becoming \textit{alternative proposition author}.

\userstory{8}
 As a \textit{user} I want to see my profile data in order to get an overview of the entries of my profile

\userstory{8}
 As a \textit{user} I want to see the profile of other users in order to get an idea of the political attitudes and affiliations of other users

\userstory{8}
 As a \textit{user} I want to see a list of all the propositions of the context I’m interested in in order to discover relevant propositions

\userstory{8}
 As a \textit{moderator} I want to be able to resolve context problems and discussion issues.

\userstory{8}
 As an \textit{admin} I want to withdraw privileges from a \textit{moderator}, making him an ordinary \textit{user}.

\userstory{8}
 As a \textit{user} I want to receive notification when other users delegate their vote.

\userstory{8}
 As a \textit{vote delegator} I want receive a notification when my vote power was used in a propositions voting phase.

\userstory{8}
 As a \textit{vote accumulator} I want to receive a notification when vote power delegate to me is withdrawn again.

\userstory{7}
 As \textit{proposition follower}, I want to author and submit a change request towards the contents of the followed proposition.

\userstory{7}
 As a \textit{proposition author}, I want to decide about a change request in order to adapt and improve the proposition.

\userstory{7}
 As a \textit{user} I want to give feedback on a proposition change request expressing my approval or rejection of the edits contained within the change request.

\userstory{7}
 As a \textit{user} I want to up- or downvote other users discussion entries.
\userstory{7}
 As a \textit{user} I want to follow a proposition of interest in order to stay updated, thereby becoming a \textit{proposition follower}.

\userstory{7}
 As a \textit{moderator} I want to receive reports on inappropriately set contexts of propositions.

\userstory{6}
 As a \textit{user} I want to report an incorrectly set context of a proposition.

\userstory{6}
 As a \textit{moderator} I want to block users violating the platform rules.

\userstory{6}
 As a \textit{moderator} I want to block propositions violating the platform rules.

\userstory{6}
 As a \textit{proposition author} I want to get notifications on new change requests pertaining to my followed propositions.

\userstory{6}
 As a \textit{context follower} I want to receive notifications about new propositions in the realms of my subscribed to contexts.

\userstory{6}
 As a \textit{user} I want to set a visibility level for each part of my profile data.

\userstory{5}
 As a \textit{proposition author} I want to change and/or update secondary contexts to follow up the discussion of appropriateness of the secondary contexts.

\userstory{5}
 As a \textit{user} I want to sort the list of propositions by multiple criteria (date created, deadline, author, № of supporters, …) in order to see propositions relevant to my criteria.

\userstory{5}
 As a \textit{user} I want to report inappropriate discussion entries to the moderators of the resp. context.

\userstory{5}
 As a \textit{proposition author}, I want to stay informed about the discussion on my proposition.

\userstory{5}
 As a \textit{moderator} I want to discuss/update the context taxonomy in collaboration with other moderators.

\userstory{5}
 As \textit{proposition follower}, I want to receive notifications about updates to my followed propositions like any changes by the proposition author and added, approved or rejected change requests.
\userstory{5}
 As \textit{proposition follower}, I want to receive notifications about the creation of alternative propositions.

\userstory{4}
 As an \textit{admin} I want to see a dashboard of moderation activities and reports.

\userstory{4}
 As an \textit{admin} I want to override moderator’s decisions.

\userstory{4}
 As an \textit{admin} I want to block or unblock users.

\userstory{4}
 As a \textit{user} I want my data to be shielded from other third parties in order preserve my private identity.

\userstory{4}
 As a \textit{discussion participant}, I want to receive notifications when somebody responds to my discussion entries.

\userstory{3}
 As a \textit{user} I want to sign up (securely) in order to use the services of the platform that require a registered account.

\userstory{3}
 As a \textit{user} I want to manage my notification settings.

\userstory{3}
 As a \textit{context follower} I want to receive a notification when the context taxonomy changes/gets updates with effects on a particular context I follow in order to be able to adjust my context subscriptions.

\userstory{3}
 As a \textit{proposition follower} I want to receive notifications of proposition results.

\userstory{2}
 As an \textit{admin} I want to adjust the platform parameters.

\section{Architectural Design}
\label{sec:ArchitecturalDesign}

While user stories are good tools to document expectations on product functions and to some extent also give hints pertaining to the user interface design, they are completely agnostic of a software systems architecture and the different layers and modules that have to work together within the software product in order to be able to achieve the desired functionality specified by the user story.\\
To break down the user stories into small actionable tasks, it is therefore a hard prerequisite for any team of software engineers and developers, no matter how agile, to think about the design of a software system's architecture.

It is quite clear that the Liquid Citizen platform will have to implement a client-server model, because it needs to manage at least a part of the data in a centralized fashion and has to be available to a large number of users over the Internet.
However, there are still a number of options available for the architecture of both client and server which we will explore in the following.

\subsection{Client-side Architecture}
\label{ssec:ClientSideArchitecture}
It is a very common pattern in contemporary software development to build a variety of thick, stateful clients that all interface with the same stateless server(s) over an API that is commonly implemented using industry standard web technology such as REST.
Clients could be implemented as single page applications rendered in the browser, server-rendered web applications, native mobile clients or native desktop clients.
We argue that native deskop clients would be a good choice for our use case, since they would need to manage a variety of cryptographic secrets which is hard to do in a proper fashion when developing for the browser.

While it can be argued that users will only ever need to interfere with a client and hence the vision a user story depicts can be easily translated to requirements on client user interfaces, there are other important techniques for user experience (UX) design that need to accompany user stories in order to develop a modern client.
However, we do not consider UX design to be relevant for this work and will therefore only concern ourselves with some formal responsibilites of the client and otherwise lay our focus on the engineering of the server side of the platform.

\subsection{Server-side Architecture}
\label{ssec:ServerSideArchitecture}

With the widespread adaption of smartphones and LTE, servers need to be able to process and respond to millions of requests from clients all over the world within milliseconds, handling hardware failure, network issues and malicious attacks amongst other stressors while maintaining a high availability of at least 3 nines (i.e. $>99.9\% $).

These fast growing requirements on server-side applications have led to a vast amount of efforts in the reinvention of server-side software architecture over the last ten to fifteen years, mainly by big tech companies such as Netflix, Facebook, Amazon and Google.
The result of these efforts was the adoption of a new type of highly modularized server-side architecture, the so-called microservices architecture.
Microservices are rather small server applications that encapsulate business logic for a small, distinguished type of application data and hide the underlying database(s) from clients.
They typically expose functionality as RESTful web services.
Microservices constitute a good architectural choice for applications where the application domain can be divided into small chunks in such a way that business processes can be carried out without complex interactions between the individual parts.

We argue that implementing the Liquid Citizen platform within the microservices model would be a good choice, as most of the individual artifacts that are to be managed by the platform such as propositions, contexts, discussion entries, user accounts and notifications are clearly separated and do not interact with each other in complicated ways.
Moreover, using the microservices architecture, each of the microservices could implement their own \tracknshrink{CS}-enabling interface and thereby offering citizen science projects to be very selective about the data they want to use, streamlining development of additional software for these projects.

%\input{img/tikz-blockdiagramm}

%As highlighted in the discussion above, we aimed for a software design that allowed for flexibility, incorporating multiple contexts and a decentralized application context / paradigm. Because of this we chose an approach centered around microservices and (as far as possible) independent modules. Since we want it to be available for many different contexts, we focus on the mechanisms and provide an architecture where the users are independent from the servers offering the services as well as the frontend. For the same reason we also don't offer a frontend solution for the implemented mechanisms, and leave the implementation of fullgrown UIs to designers of applications of the software.


%As mentioned in the introduction of this section, the system architecture of Liquid Citizen is highly decentralized and modular.
%Different components are realized self-sufficiently, with their own APIs, in their own docker containers, and are developed in their respective \href{https://github.com/Liquid-Citizen}{github repositories}.
%Since the different components operate on distinct ports, they can be run on the same machine; However, to be true to the decentralized standard of the system, they can run on different machines just as well.
%Thus their development as well as their production is entirely encapsulated within itself.

%Since the components however form a service ecosystem where the different components need to interact / exchange data with one another, care needs to be taken to integrate the components well with one another, which violates their independence, but is needed for functionality. These aspects will be discussed in the following, in the \hyperref[ssec:Microservices]{description of the microservices}. The respective components, as modules of the software, are sketched \hyperref[ssec:Modules]{afterwards}.


\section{An Exemplary Application Design}
\label{sec:ApplicationDesign}
A complete application design encompasses amonst others chososing programming languages, technologies, frameworks as well as developing APIs and business processes.

Since we are just aiming to provide a minimal exemplary application design, we will skip the very technical parts of choosing programming language, specific technologies, frameworks, etc. and instead focus on a more abstract perspective, only involving APIs and their interaction as business processes.

We choose to depict this examplary application design in the light of the microservices architecture for the server-side and a native desktop client on the for the client-side.
Therefore, we will now derive a list of microservices needed and detail their interaction with each other and the desktop client.


\subsection{Microservices}
\label{ssec:ApplicationDesign_MS}
Compiling a list of microservices is usually done by analyzing the application domain, splitting it into small subdomains and determining breaking points for microservices in order to minimize their dependencies with one another.
The list of artifacts we have discussed in \autoref{ssec:data_fragments} should give us a good overview of our subdomains and in turn make it easy to aggregate some of them to come up with a final list of microservices.
\begin{enumerate}
  \item Propositions
  \item Discussion Entries
  \item Proposition Change Requests
  \item Alternative Propositions and Proposition Groups
  \item Context Taxonomy
  \item Delegation Graphs
  \item User Accounts
  \item User Intents
  \item Participation Privileges
  \item Notifications
  \item Moderation Requests
\end{enumerate}

We can strip away user intents and participation privileges, since these, as argued in \autoref{sec:User_Intent_Dissemination}, are not managed by the platform itself.
As a consequence, we can also remove delegation graphs from this list, as they are composed from user intents on-demand and do not need to be materialized in the platform itself.

Propositions, alternative propositions, proposition groups and proposition change requests arguably are very interrelated and describe the same domain of propositions.
They can therefore be managed by the same microservice.

We observe that moderation requests can be seen as a special form of notification triggered by the user and directed towards all moderators.

Our preliminary list of subdomains therefore is:
\begin{enumerate}
  \item Proposition Domain
  \item Discussion Domain
  \item Context Domain
  \item User Domain
  \item Notification Domain
\end{enumerate}

A domain not recorded in this list, as it is more process-oriented, is authentication.
This domain is not included in and should not be mixed with the user domain, as authentication could be done by external authentication providers.
Authorization however could be managed within the user domain.

Furthermore, the central trusted authority (CAT), as introduced in \autoref{sec:User_Intent_Dissemination}, should receive its own microservice for security as well as reusability reasons, although it would theoretically be possible to fit it into the user domain.

The final list of microservices therefore becomes:
\begin{enumerate}
  \item Proposition Microservice
  \item Discussion Microservice
  \item Context Microservice
  \item User Microservice
  \item Notification Microservice
  \item Authentication Microservice
  \item CAT Microservice
\end{enumerate}

The utility of microservices shines with this design: the horizontal partitioning of the application domain allows to scale up availability and responsiveness of the platform by spawning multiple instances of the same microservice.
These instances could furthermore be allowed to scale up with the amount of data they need to manage by also partitioning them vertically.
For example, we could partition proposition microservices by the primary context of proposition groups, such that for each subtree in the context taxonomy belonging to one big supercontext we spawn one instance of the proposition microservice.

\subsection{Client }
\label{sec:ApplicationDesign}

\todo{@KD: structure, fill}


%
% \subsection{Proposition Server}
%
% \paragraph*{POST: createProposition()} \mbox{} \\
% Creates a new proposition according to the parameters transmitted, as well as the proposition group alternative propositions to the newly created proposition will belong to.
%
% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.
%
% \paragraph*{POST: createAlternativeProposition(propositionGroupID)} \mbox{} \\
% Creates a new alternative proposition belonging to the propositionGroupID of the referred proposition.
%
% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.
%
% \paragraph*{POST: createPropositionToken(propositionID,plainTextOption)} \mbox{} \\
% Creates a propositionToken for the respective proposition, associated with the respective plainTextOption (as long as the proposition and the option exists). The propositionToken can be used to derive the plainTextOption associated with it, and is introduced so the plainTextOption can't be manipulated by other actors in the vote evaluation process.
%
% \paragraph*{POST: derivePlainTextOption(propositionToken)} \mbox{} \\
% Returns the plain text option associated with the proposition token.
%
%
% \paragraph*{GET: getPropositionInformation(propositionID, foobar)} \mbox{} \\
% Will return relevant information about the proposition in question.
%
% \paragraph*{GET: getPropositionVoteClosingTime(propositionID)} \mbox{} \\
% Returns the vote closing time of the proposition (when the voting period ended).
%
% \paragraph*{GET: getPropositionVoteOpeningTime(propositionID)} \mbox{} \\
% Returns the vote opening time of the proposition (when the voting period started).
%
% \paragraph*{POST: signVote(vote)} \mbox{} \\
% Signs a vote with the current time stamp to prove that the vote was casted on time. 
%
% \paragraph*{Data base structure proposition service} \mbox{} \\
% The proposition service stores the data for the propositions as well as the proposition tokens used for vote casting. For this it features two tables, one with the proposition data (to be specified) and one with a mapping of the optionTokens and the respective plainTextOptions.
%
%


\section{Public Declaration of User Intent Protocol}
\label{sec:PublicDeclarationOfIntentProtocol}
The public declaration of intent protocol describes how to secretly post or withdraw a vote, support or delegation intent to a public space.
Since the protocol makes heavy usage of the RSA cryptosystem, we will first give an overview of its capabilities and properties, although we will not strive to make this very technical\footnote{a thorough technical definition and description of the RSA cryptosystem can be found at \url{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}}.

\subsection{The RSA Cryptosystem}
A cryptosystem is a system of cryptographic algorithms which are commonly used for encryption.
It typically consists of a key generation algorithm, an encryption algorithm and a decryption algorithm.
The RSA cryptosystem is an asymmetric cyptosystem which means that the key generation algorithm generates a pair of keys, denoted private and public key, which can interchangeably be used for encryption and decryption respectively.

RSA relies on the hardness of prime factorization and the discrete logarithm problem for its cryptographic properties.
The most important property of RSA is the length of the generated keys, which on one hand determines its safety, as the problem gets harder with increasing key length, and on the other hand sets an upper limit on the size of the messages one may encrypt or decrypt with an RSA key pair of a given length.

In practice, RSA is mostly used in order to exchange a key for a symmetric cryptosystem, such as AES, that can encrypt messages of arbitrary sizes.
If Alice wants to communicate with Bob through a safe channel, she can therefore generate a secret symmetrical key, encrypt it with Bob's public key and send it to Bob.
As only Bob has knowledge of his private key, no man-in-the-middle attacker could obtain knowledge of the secret key.
Once Bob has decrypted the secret it becomes a shared the secret and both Alice and Bob can send each other arbitray messages encrypted with the shared secret and likewise decrypt it using the same shared secret.

Another common usage of RSA are electronic signatures, which we will use in this work.
If Alice wants to sign an arbitrarily sized message such that Bob can be sure the message is indeed from Alice and was not modified by a man-in-the-middle attacker, Alice uses a cryptographic hashing algorithm to obtain a fixed length hash of her message.
She then generated her signature by encrypting this hash with her private key.
Bob, who has knowledge of her public key and the hashing function used, can then decrypt the signature to obtain the hash of Alice's original message.
If this hash is equal to the hash of the message he has received, Alice was indeed the sender and the message has not been tampered with.

Blind signatures, as briefly discussed in \autoref{sec:User_Intent_Dissemination}, can be realized leveraging an interesting multiplicative property of RSA which allows to use a random blinding factor for obfuscation of the original message before transmitting it to an authority for signature, therefore not leaking any information about the original message to the authority.
After obtaining the signature from the authority, the blinding factor can be used to obtain a valid signature for the original message.

\subsection{Protocol Specification}
The protocol is divided into a number of steps necessary to obtain a participation privilege, and cast a user intent to the public space. For each of the steps, we will motivate it, define it using a list of technical instructions and give an informal proof of its correctness.

\subsubsection{Obtaining Participation Privilege}
The participation privilege (see \autoref{ssec:Participation_Privileges}) is the cornerstone of posting anonymized, secure user intents to a public space.
Users first need to obtain a participation privilege, which acts as an alias, from a central trusted authority (CTA).
A new participation privileges needs to be obtained for each type of user intent and each scope in order to prevent adversaries from deducing sensitive information about certain users through structural analysis.
Therefore, the CTA has to (1) keep a list of users that have obtained their partipation privilege for each combination of user intent type and scope.
As has been stated in \autoref{sec:User_Intent_Dissemination}, when obtaining a participation privilege, a blind signature scheme should be utilized.
To this end, we will use the already introduced RSA blind signature scheme.
As the validity of a user intent depends on the combination of its type and scope, the CTA needs to generate a unique RSA key pair of each combination.
The public keys from these pairs need to be published such that anyone can get the public key for a given combination of user intent type and scope.

Participation privileges are made up of two components.
The first component is a user-generated token which serves as an alias of the user.
The second component is the CTA's signature on the token, which effectively makes it a valid participation privilege.
As already became clear, a token should contain a unique id as well as data describing the type and scope of user intents it is directed at.
We use RSA public keys as unique ids, as for reasonable key sizes\footnote{The recommended RSA key size is 2048 bit, while 1024 bit is also a common and reasonable choice for some applications. RSA keys should however not be less than 1024bit long in order to be practically secure.} they can be assumed to be practically unique, given that the generation algorithm is provided a good amount of entropy.

%Furthermore, using RSA public keys as unique ids allows us to construct proofs of ownership for user intents, but we will get to that later.

 
Let $t$ be the type of user intent for which the participation privilege should be issued and let $s$ be the scope for which the participation privilege should be issued.
The public and private keys of the CTA can be obtained from the functions $ \kappa_\textit{priv}(t,s)$ and $ \kappa_\textit{pub}(t,s)$.
The steps to obtain a participation privilege for a given proposition group or proposition are:


% OBTAIN PP:
% PP_1 := (IDPUBKEY) (TYPE) (SCOPE) 
% SIG_1 := RSA_ENCRYPT(BLINDPRIVKEY, HASH(PP_1))
% SIG_2 := RSA_ENCRYPT(CTAPRIVKEY(SCOPE), SIG_1)
% SIG := RSA_DECRYPT(BLINDPUBKEY, SIG_2)
% PP := (PP_1) (SIG)
%

\begin{enumerate}
\item The user creates a fresh RSA key pair $id \defeq \langle id_{\textit{priv}}, id_{\textit{pub}} \rangle$
\item The user assembles its token as $\theta \defeq \{id_{\textit{pub}}, t, s\} $
\item Using a cryptographic hash function $H$, the user calculates the tokens hash: $\eta \defeq H(\{id_{\textit{pub}}, t, s\})$
\item The user generates a blinding factor  $b$ and calculates $\beta \defeq \texttt{blind}(\eta, b)$
\item The user submits $(s, t, \beta)$ to the CTA together with its authentication information
\item If the CTA determines that the user is not authorized to participate or has already obtained his participation privilege for $(s,t)$, it denies the signature and the protocol \textbf{stops}
\item Otherwise, the CTA signs the blinded token with its private key for the given combination of user intent type and scope, yielding $\sigma\defeq \texttt{RSA\_Encrypt}(\beta,  \kappa_\textit{priv}(t,s))$
\item The user unblinds the CTA's signature as $\omega \defeq \texttt{unblind}(\sigma, b)$
\item The user assembles its participation privilege as $pp \defeq \{id_{\textit{pub}}, t, s, \omega\}$
\end{enumerate}

\paragraph{Checking Participation Privileges}
Anyone can easily verify the validity of a participation privilege by checking if $\texttt{RSA\_Decrypt}(\omega,  \kappa_\textit{priv}(t,s)) = H(\{id_{\textit{pub}}, t, s\})$ holds.

\subsubsection{Assembling User Intent Messages}
Now that we have seen how to obtain a participation privilege from the CTA, we will look into assembling the different types of user intents.

First, we will have to define a mechanism to assure legality of a user intent, i.e. that it was indeed authored by the legal owner of the participation privilege and furthermore, that it was authored within a given participation period, e.g. the voting period.
To this end, we introduce the notion of a \emph{proof of legality (POL)}, which combines two cryptographic signatues in order verify authorship and punctuality, respectively.
The authorship can easily be proven using the private RSA key corresponding to the public RSA key in the participation privilege in order to generate a signature of the whole user intent message.
We argue that punctuality should only be handled on a daily granularity level, i.e. all participation periods (as the ones defined in \autoref{ssec:Model_Propositions_Life}) should always start and end at 12 a.m. for a fixed time zone.
Therefore, it is feasible to let the CTA generate a new pair of RSA keys for each day, such that they might be used in a blind signature scheme which will be our proof of punctuality.

As noted in \autoref{sec:User_Intent_Dissemination}, user should be able to issue multiple user intents of the same type and scope in order to be able to change their mind at any time within a given participation period.
We therefore need a mechanism of detecting the most recent user intent for a given participation privilege, effectively invalidating the previous ones.

To this end, we introduce the notion of a \emph{sequence id}, which is an integer counter that should be initialized as one and be incremented by the user for each subsequent, overriding user intent he formulates using the same participation privilege.
For a given participation privilege, only the legal user intent with the highest sequence id is considered valid.
User intents with sequence ids of less than one must be considered invalid.
If there exist multiple user intents with the same sequence id for a given participation privilege, they all  must be considered invalid. 
Note that only legal user intents are considered for validity checking, i.e. it is impossible to invalidate a legal user intent by formulating an illegal user intent with the same participation privilege and sequence id as the first one.

One problem that we did not discuss in \autoref{sec:User_Intent_Dissemination} is how to keep user intents secret until the corresponding participation period ends.
The motivation for keeping user intents secret before the end of the corresponding participation period is to prevent, for example, tactical voting in the voting period.
We tackle this problem by introducing a two step protocol for assembly and dissemination of user intent messages.
In the first step, we assemble a hidden user intent message, which means that the actual choices of the user are encrypted.
In a second step, we then release the key for decryption using the same sequence id as in the first message.
Note that the \emph{secret user intent messages} in the first step must be assembled within the given participation period, e.g. secret voting intents must be assembled and signed within the voting period, while the corresponding \emph{revealing user intent messages} need to be assembled within a set amount of days \emph{after} the period has ended.

In the following we will give a formal method for the assembly of an arbitrary user intent message, i.e. with an arbitrary intention content.
Thereafter, we will detail how the intention contents of the different user intent types are structured.
Let $d$ be the true current date and $d'$ be an arbitrary date which is expected to be the current date, but could be forged.
The function $\Delta(d)$ calculates the number of days since January 1 1970 12 a.m. UTC.
Let $\delta_\textit{priv}(\Delta(d)), \delta_\textit{pub}(\Delta(d))$ denote the private and public keys the CTA generated for $\Delta(d)$.
Finally, let $seq$ be a sequence id, $\iota$ be the intention content of the message and $H$ be a cryptographic hash function.
The steps used to assemble the secret message are as follows:
% ASSEMBLE MSG:
% HDID := RSA_ENCRYPT(REVKEY(PP, SEQ), HASH(DID))
% HUIC := RSA_ENCRYPT(REVKEY(PP, SEQ), HASH(UIC))
% MSG_1 := (PP) (SEQ) (TS) [(HDID)] (HUIC) 
% POA := BLIND(b, RSA_ENCRYPT(IDPRIVKEY, HASH(MSG_1)))
% POV_1 := RSA_ENCRYPT(CTAPRIVKEY(TIME), POA_1)
% POV := UNBLIND(b, POV_1)
% MSG := (MSG_1) (POV)


\begin{enumerate}
\item The user creates a fresh RSA key pair $\rho \defeq \langle \rho_{\textit{priv}}, \rho_{\textit{pub}} \rangle$
\item The user generates a signature for the intention content as $\tau \defeq \texttt{RSA\_Encrypt}(H(\iota), \rho_\textit{priv})$
\item The user assembles the message contents as $m \defeq \{pp, seq, \Delta(d'), \tau \}$ 
\item Using a cryptographic hash function $H$, the user calculates the messages hash: $\eta \defeq H(m)$
\item The user creates the proof of authorship as $\alpha \defeq \texttt{RSA\_Encrypt}(H(m), id_\textit{priv})$
\item The user generates a blinding factor $b$ and calculates $\beta \defeq \texttt{blind}(\alpha, b)$
\item The user submits $\beta$ to the CTA
\item The CTA signs $\beta$ using its private key for $d$, yielding $\sigma\defeq \texttt{RSA\_Encrypt}(\beta,  \delta_\textit{priv}(\Delta(d)))$
\item The user now generates the proof of legality as $\lambda \defeq \texttt{unblind}(\sigma, b)$
\item The user now assembles the final message as $msg \defeq \{pp, seq, \Delta(d'), \tau, \lambda \}$
\end{enumerate}

The steps used to assemble the reveal message are as follows:

\begin{enumerate}
\item The user assembles the message contents as $m \defeq \{pp, seq, \Delta(d'), \iota, \rho_{\textit{pub}}  \}$ 
\item Using a cryptographic hash function $H$, the user calculates the messages hash: $\eta \defeq H(m)$
\item The user creates the proof of authorship as $\alpha \defeq \texttt{RSA\_Encrypt}(H(m), id_\textit{priv})$
\item The user generates a blinding factor $b$ and calculates $\beta \defeq \texttt{blind}(\alpha, b)$
\item The user submits $\beta$ to the CTA
\item The CTA signs $\beta$ using its private key for $d$, yielding $\sigma\defeq \texttt{RSA\_Encrypt}(\beta,  \delta_\textit{priv}(\Delta(d)))$
\item The user now generates the proof of legality as $\lambda \defeq \texttt{unblind}(\sigma, b)$
\item The user now assembles the final message as $msg \defeq \{pp, seq, \Delta(d'), \iota, \rho_{\textit{pub}}, \lambda \}$
\end{enumerate}

\paragraph{Checking Proof of Validity}
% RSA_DECRYPT(IDPUBKEY, POO) == HASH(MSG_1)
%
% RSA_DECRYPT(CTAPUBKEY(SCOPE), POP) == HASH(HASH(MSG), TS) && TS IN PERIOD(SCOPE)
%
% RSA_DECRYPT(CTAPUBKEY(SCOPE), POP) == HASH(HASH(MSG), TS) && TS > PERIOD(SCOPE)
%

\paragraph{Checking Validity of Reveal Message}
% CHECK REVEAL VALIDITY:
% RSA_DECRYPT(REVKEY(PP, SEQ), HDID) == HASH(RDID) &&
% RSA_DECRYPT(REVKEY(PP, SEQ), HUIC) == HASH(RUIC)

\todo{@KD: digest notes to text}

\section{Vote Tallying Protocol}
\label{sec:VoteTallyingProtocol}
The vote tallying protocoll describes the steps necessary to carry out vote tallying in the public space for some proposition after its voting phase has ended.
It can be implemented as part of a vote(-delegation) client, as a public service and directly within the platform.
The idea is that everyone is able to carry out the vote tallying process purely relying on public, signed data.
As counting support scores and counting votes have merely semantical differences, for sake of brevity we chose to only describe the vote counting process here:

\begin{enumerate}
  \item For a given proposition group $p$, collect all \textit{valid} user intents from the public space
  \item Build the delegation graph $\mathcal{D}$ from the delegation intents
  \item Invert all edges in $\mathcal{D}$ to obtain $\mathcal{D}^I$\footnote{Replace all directed edges $(u,v)$ by edges $(v,u)$, $u,v \in N, (u,v) \in E$, with $D=(N,E)$}
  \item All vote intents are collected in a list $V$
  \item If $V$ is not exhausted, assign the next vote intent in $V$ to $v$, else terminate
  \item Check $v$ against the central trusted authority for validity 
  \item If $v$ is not valid, return to number 5
  \item Initialize the voting power $p_v$ of $v$ to 1
  \item If $\mathcal{D}^I$ does not contain $v$, advance to number 13
  \item Remove all incoming edges of $v$ in $\mathcal{D}^I$
  \item Find all nodes $S$ in $\mathcal{D}^I$ that are reachable from $v$
  \item Set $p_v$ to $|S|+1$
  \item In the voting protocol, add $p_v$ to the vote count for the voting option that $v$ voted for
  \item Return to number 5
\end{enumerate}


%\section{Demo Application}
%\label{ssec:DemoApplication}
