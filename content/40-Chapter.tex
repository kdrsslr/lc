\chapter{Engineering the Liquid Citizen Platform}
\label{ch:ProjectRequirements}
This chapter will distill the efforts of all the previous chapters leading to the concrete design of a citizen science-enabled liquid 
democracy platform from a software engineering perspective.
Based on the \hyperref[ch:Approach]{discussion of the approach} in \autoref{ch:Approach}, to fulfill the objective of this project, and due to the fact that no suitable software exists to base the project on, this section will document the initial software engineering process upon which can be built in order to realize a platform that meets the derived \hyperref[sec:Criteria]{criteria} for a \tracknshrink{CS}-enabled \tracknshrink{LD} platform.

Therefore, we start by explicitly documenting the \hyperref[sec:SoftwareRequirements]{software requirements} which we derive from the previous chapters.
We then continue by laying the foundation for a more technical view of the platform by discussing possibilities of its \hyperref[sec:ArchitecturalDesign]{architectural design} before we go into detail on the available options concerning the \hyperref[sec:ApplicationDesign]{application design} in the exemplary setting of a microservices architecture and a local client.
The chapter is then concluded by the specification of two protocols, namely the \hyperref[sec:PublicDeclarationOfIntentProtocol]{public declaration of intent protocol} and the \hyperref[sec:VoteTallyingProtocol]{vote tallying protocol}, that revolve around vote, support and delegation intents posted in the public space.


% narrative: discuss architectural design -> choose microservices
% how to name the section on the actual microservices implementations?



%we will \hyperref[sec:SoftwareRequirements]{derive software requirements} the prototype needs to fulfill, before describing the \hyperref[sec:Implementation]{process of implementing} said prototype.
%Since we base our prototype on a modular architecture around microservices, we will focus predominantly on the \hyperref[ssec:Architecture]{architecture} of the prototype, as well as a detailed description of the implemented \hyperref[ssec:Microservices]{micro services}.
%Then, we define two protocols, namely the \hyperref[sec:PublicDeclarationOfIntentProtocoll]{public interaction protocol} and the \hyperref[sec:VoteTallyingProtocol]{vote tallying protocol}, that revolve around vote and delegation intents in the public space.
%Finally, we present the \hyperref[ssec:DemoApplication]{demo application} that showcases the integration of all the previously introduced parts of the platform.
\section{Software Requirements}
\label{sec:SoftwareRequirements}

Every software engineering process begins with a requirements analysis whose execution will differ considerably depending on which software engineering methodology is being used.
The goal of all requirements analysis processes is to identify the requirements towards the envisioned software product from a variety of different angles, i.e. how is the software used by different user roles, how should it interface with existing software, which of these are functional requirements and which are non-functional.

For the sake of brevity and to increase the agility of potential developers of the platform, we chose to follow the scrum methodologies approach to requirements analysis.
In the scrum method, requirements are formulated as so called user stories.
A user story is a statement of the form "As X I want Y (in order to [reach a Z])."), where X is a user role, Y is the detailed description of an activity the given role should be able to perform with the envisioned final software product and Z is the goal the user wants to reach.
In the scrum methodology, user stories are then broken down into tasks which are assigned to contributors / developers in scrum sprints.

However, we are aiming for an abstract albeit accurate documentation of the Liquid Citizen platform's requirements, not for a step-by-step manual, which we could not provide anyway without the knowledge of final decisions in the compartments of architecture, languages and frameworks used.
To this end, we will now record all requirements that can be extracted from our previous discussion in chapters~\ref{ch:Theory}~and~\ref{ch:Approach} as user stories.
We have assigned a priority score between one and ten to each user story. Stories scoring 10 are absolutely necessary for the simplest of prototypes, while those on the other end of the spectrum are not necessary for the core functionality at all and could potentially be delivered as updates even after the platform is already used in production.

\userstory{10}
As a \textit{user} I want to initiate a proposition in order start the political process in a certain context of my interest, thereby becoming the \textit{proposition author} of the newly initiated proposition.

\userstory{10}
As a \textit{user} and potential \textit{vote accumulator} I want to vote on a proposition in the voting phase.

\userstory{10}
As a \textit{user} I want to delegate my vote to someone else, becoming a \textit{vote delegator} and making that someone a \textit{vote accumulator}.

\userstory{9}
As a \textit{user} I want to support a proposition group in order to propel it to the discussion phase, thereby becoming \textit{proposition group supporter}.

\userstory{9}
 As a \textit{user} I want support a proposition in a discussion phase in order to propel it to the voting phase, thereby becoming a \textit{proposition supporter}.

\userstory{9}
 As a \textit{user} I want to create a discussion entry on a proposition or change request, thereby becoming a \textit{discussion participant} and a \textit{proposition follower}.

\userstory{9}
 As a \textit{proposition author}, I want to modify the contents of my proposition.

\userstory{9}
 As a \textit{user} I want to edit my context subscriptions in my profile, becoming a \textit{context follower} of each context subscribed to.

\userstory{9}
 As an \textit{admin} I want to delete \textit{users}.

\userstory{8}
 As a \textit{user} I want to change my profile data (change password, mail, political affiliations such as party membership) in order to reflect my current my political profile.
 
 \userstory{8}
 As a \textit{user} I want to create an alternative proposition on an existing proposition, putting it in the original propositions proposition group and inheriting its primary context, thereby becoming \textit{alternative proposition author}.

\userstory{8}
 As a \textit{user} I want to see my profile data in order to get an overview of the entries of my profile

\userstory{8}
 As a \textit{user} I want to see the profile of other users in order to get an idea of the political attitudes and affiliations of other users

\userstory{8}
 As a \textit{user} I want to see a list of all the propositions of the context I’m interested in in order to discover relevant propositions

\userstory{8}
 As a \textit{moderator} I want to be able to resolve context problems and discussion issues.

\userstory{8}
 As an \textit{admin} I want to withdraw privileges from a \textit{moderator}, making him an ordinary \textit{user}.

\userstory{8}
 As a \textit{user} I want to receive notification when other users delegate their vote.

\userstory{8}
 As a \textit{vote delegator} I want receive a notification when my vote power was used in a propositions voting phase.

\userstory{8}
 As a \textit{vote accumulator} I want to receive a notification when vote power delegate to me is withdrawn again.

\userstory{7}
 As \textit{proposition follower}, I want to author and submit a change request towards the contents of the followed proposition.

\userstory{7}
 As a \textit{proposition author}, I want to decide about a change request in order to adapt and improve the proposition.

\userstory{7}
 As a \textit{user} I want to give feedback on a proposition change request expressing my approval or rejection of the edits contained within the change request.

\userstory{7}
 As a \textit{user} I want to up- or downvote other users discussion entries.
\userstory{7}
 As a \textit{user} I want to follow a proposition of interest in order to stay updated, thereby becoming a \textit{proposition follower}.

\userstory{7}
 As a \textit{moderator} I want to receive reports on inappropriately set contexts of propositions.

\userstory{6}
 As a \textit{user} I want to report an incorrectly set context of a proposition.

\userstory{6}
 As a \textit{moderator} I want to block users violating the platform rules.

\userstory{6}
 As a \textit{moderator} I want to block propositions violating the platform rules.

\userstory{6}
 As a \textit{proposition author} I want to get notifications on new change requests pertaining to my followed propositions.

\userstory{6}
 As a \textit{context follower} I want to receive notifications about new propositions in the realms of my subscribed to contexts.

\userstory{6}
 As a \textit{user} I want to set a visibility level for each part of my profile data.

\userstory{5}
 As a \textit{proposition author} I want to change and/or update secondary contexts to follow up the discussion of appropriateness of the secondary contexts.

\userstory{5}
 As a \textit{user} I want to sort the list of propositions by multiple criteria (date created, deadline, author, № of supporters, …) in order to see propositions relevant to my criteria.

\userstory{5}
 As a \textit{user} I want to report inappropriate discussion entries to the moderators of the resp. context.

\userstory{5}
 As a \textit{proposition author}, I want to stay informed about the discussion on my proposition.

\userstory{5}
 As a \textit{moderator} I want to discuss/update the context taxonomy in collaboration with other moderators.

\userstory{5}
 As \textit{proposition follower}, I want to receive notifications about updates to my followed propositions like any changes by the proposition author and added, approved or rejected change requests.
\userstory{5}
 As \textit{proposition follower}, I want to receive notifications about the creation of alternative propositions.

\userstory{4}
 As an \textit{admin} I want to see a dashboard of moderation activities and reports.

\userstory{4}
 As an \textit{admin} I want to override moderator’s decisions.

\userstory{4}
 As an \textit{admin} I want to block or unblock users.

\userstory{4}
 As a \textit{user} I want my data to be shielded from other third parties in order preserve my private identity.

\userstory{4}
 As a \textit{discussion participant}, I want to receive notifications when somebody responds to my discussion entries.

\userstory{3}
 As a \textit{user} I want to sign up (securely) in order to use the services of the platform that require a registered account.

\userstory{3}
 As a \textit{user} I want to manage my notification settings.

\userstory{3}
 As a \textit{context follower} I want to receive a notification when the context taxonomy changes/gets updates with effects on a particular context I follow in order to be able to adjust my context subscriptions.

\userstory{3}
 As a \textit{proposition follower} I want to receive notifications of proposition results.

\userstory{2}
 As an \textit{admin} I want to adjust the platform parameters.

\section{Architectural Design}
\label{sec:ArchitecturalDesign}

While user stories are good tools to document expectations on product functions and to some extent also give hints pertaining to the user interface design, they are completely agnostic of a software systems architecture and the different layers and modules that have to work together within the software product in order to be able to achieve the desired functionality specified by the user story.\\
To break down the user stories into small actionable tasks, it is therefore a hard prerequisite for any team of software engineers and developers, no matter how agile, to think about the design of a software system's architecture.

It is quite clear that the Liquid Citizen platform will have to implement a client-server model, because it needs to manage at least a part of the data in a centralized fashion and has to be available to a large number of users over the Internet.
However, there are still a number of options available for the architecture of both client and server which we will explore in the following.

\subsection{Client-side Architecture}
\label{ssec:ClientSideArchitecture}
It is a very common pattern in contemporary software development to build a variety of thick, stateful clients that all interface with the same stateless server(s) over an API that is commonly implemented using industry standard web technology such as REST.
Clients could be implemented as single page applications rendered in the browser, server-rendered web applications, native mobile clients or native desktop clients.
We argue that native deskop clients would be a good choice for our use case, since they would need to manage a variety of cryptographic secrets which is hard to do in a proper fashion when developing for the browser.

While it can be argued that users will only ever need to interfere with a client and hence the vision a user story depicts can be easily translated to requirements on client user interfaces, there are other important techniques for user experience (UX) design that need to accompany user stories in order to develop a modern client.
However, we do not consider UX design to be relevant for this work and will therefore only concern ourselves with some formal responsibilites of the client and otherwise lay our focus on the engineering of the server side of the platform.

\subsection{Server-side Architecture}
\label{ssec:ServerSideArchitecture}

With the widespread adaption of smartphones and LTE, servers need to be able to process and respond to millions of requests from clients all over the world within milliseconds, handling hardware failure, network issues and malicious attacks amongst other stressors while maintaining a high availability of at least 3 nines (i.e. $>99.9\% $).

These fast growing requirements on server-side applications have led to a vast amount of efforts in the reinvention of server-side software architecture over the last ten to fifteen years, mainly by big tech companies such as Netflix, Facebook, Amazon and Google.
The result of these efforts was the adoption of a new type of highly modularized server-side architecture, the so-called microservices architecture.
Microservices are rather small server applications that encapsulate business logic for a small, distinguished type of application data and hide the underlying database(s) from clients.
They typically expose functionality as RESTful web services.
Microservices constitute a good architectural choice for applications where the application domain can be divided into small chunks in such a way that business processes can be carried out without complex interactions between the individual parts.

We argue that implementing the Liquid Citizen platform within the microservices model would be a good choice, as most of the individual artifacts that are to be managed by the platform such as propositions, contexts, discussion entries, user accounts and notifications are clearly separated and do not interact with each other in complicated ways.
Moreover, using the microservices architecture, each of the microservices could implement their own \tracknshrink{CS}-enabling interface and thereby offering citizen science projects to be very selective about the data they want to use, streamlining development of additional software for these projects.

%\input{img/tikz-blockdiagramm}

%As highlighted in the discussion above, we aimed for a software design that allowed for flexibility, incorporating multiple contexts and a decentralized application context / paradigm. Because of this we chose an approach centered around microservices and (as far as possible) independent modules. Since we want it to be available for many different contexts, we focus on the mechanisms and provide an architecture where the users are independent from the servers offering the services as well as the frontend. For the same reason we also don't offer a frontend solution for the implemented mechanisms, and leave the implementation of fullgrown UIs to designers of applications of the software.


%As mentioned in the introduction of this section, the system architecture of Liquid Citizen is highly decentralized and modular.
%Different components are realized self-sufficiently, with their own APIs, in their own docker containers, and are developed in their respective \href{https://github.com/Liquid-Citizen}{github repositories}.
%Since the different components operate on distinct ports, they can be run on the same machine; However, to be true to the decentralized standard of the system, they can run on different machines just as well.
%Thus their development as well as their production is entirely encapsulated within itself.

%Since the components however form a service ecosystem where the different components need to interact / exchange data with one another, care needs to be taken to integrate the components well with one another, which violates their independence, but is needed for functionality. These aspects will be discussed in the following, in the \hyperref[ssec:Microservices]{description of the microservices}. The respective components, as modules of the software, are sketched \hyperref[ssec:Modules]{afterwards}.


\section{An Exemplary Application Design}
\label{sec:ApplicationDesign}
A complete application design encompasses amonst others chososing programming languages, technologies, frameworks as well as developing APIs and business processes.

Since we are just aiming to provide a minimal exemplary application design, we will skip the very technical parts of choosing programming language, specific technologies, frameworks, etc. and instead focus on a more abstract perspective, only involving APIs and their interaction as business processes.

We choose to depict this examplary application design in the light of the microservices architecture for the server-side and a native desktop client on the for the client-side.
Therefore, we will now derive a list of microservices needed and detail their interaction with the desktop client.

\todo{@KD: structure, fill}


%
% \subsection{Proposition Server}
%
% \paragraph*{POST: createProposition()} \mbox{} \\
% Creates a new proposition according to the parameters transmitted, as well as the proposition group alternative propositions to the newly created proposition will belong to.
%
% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.
%
% \paragraph*{POST: createAlternativeProposition(propositionGroupID)} \mbox{} \\
% Creates a new alternative proposition belonging to the propositionGroupID of the referred proposition.
%
% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.
%
% \paragraph*{POST: createPropositionToken(propositionID,plainTextOption)} \mbox{} \\
% Creates a propositionToken for the respective proposition, associated with the respective plainTextOption (as long as the proposition and the option exists). The propositionToken can be used to derive the plainTextOption associated with it, and is introduced so the plainTextOption can't be manipulated by other actors in the vote evaluation process.
%
% \paragraph*{POST: derivePlainTextOption(propositionToken)} \mbox{} \\
% Returns the plain text option associated with the proposition token.
%
%
% \paragraph*{GET: getPropositionInformation(propositionID, foobar)} \mbox{} \\
% Will return relevant information about the proposition in question.
%
% \paragraph*{GET: getPropositionVoteClosingTime(propositionID)} \mbox{} \\
% Returns the vote closing time of the proposition (when the voting period ended).
%
% \paragraph*{GET: getPropositionVoteOpeningTime(propositionID)} \mbox{} \\
% Returns the vote opening time of the proposition (when the voting period started).
%
% \paragraph*{POST: signVote(vote)} \mbox{} \\
% Signs a vote with the current time stamp to prove that the vote was casted on time. 
%
% \paragraph*{Data base structure proposition service} \mbox{} \\
% The proposition service stores the data for the propositions as well as the proposition tokens used for vote casting. For this it features two tables, one with the proposition data (to be specified) and one with a mapping of the optionTokens and the respective plainTextOptions.
%
%


\section{Public Declaration of User Intent Protocol}
\label{sec:PublicDeclarationOfIntentProtocol}
The public declaration of intent protocol describes how to secretly post or withdraw a vote, support or delegation intent to a public space.
%This protocol needs to be implemented by a client that optimally should be external to the platform for security reasons.
The protocol describes three processes, namely
\begin{enumerate}
  \item Obtaining Participation Privilege
  \item Assembling User Intent Messages
  \item Time Stamping User Intent Messages
\end{enumerate}

Each of these processes will be discussed in detail below.

\subsection{Obtaining Participation Privilege}
The participation privilege (see \autoref{ssec:Participation_Privileges}) is the cornerstone of posting anonymized, secure user intents to a public space.
Users first need to obtain a participation privilege, which acts as an alias, from a central trusted authority (CTA).
A new participation privileges needs to be obtained for each proposition, proposition group and change request, in order to prevent adversaries from deducing sensitive information about certain users through structural analysis.
As has been stated in \autoref{sec:User_Intent_Emission}, when obtaining a participation privilege, a blind signature scheme should be utilized in order to preserve secrecy of user intents even against the CTA which manages participation privileges.
It can be infered from this statement that technically, participation privileges are made up of two components.
The first component is a user-defined tokens, which serves as the alias for the user.
The second component is the CTA's signature on the token, which effectively makes it a valid participation privilege.
Note that blind signature schemes are mostly based on the RSA cryptosystem.
 
The steps to obtain a participation privilege for a given proposition, proposition group or change request $x$ therefore are:
\begin{enumerate}
\item The user creates a fresh RSA key pair $\langle k_s, k_p\rangle$
\item 
%The length of the key should be as large as possible to protect against attacks for the foreseeable future.
\item The user authenticates at the CTA.
\item If the CTA determines that the user is authorized to participate and he has not, the vote registry blind signs the public key the user has generated in the first step.
\item The user can now announce vote or delegate intents to the public.
To this end, the user assembles the appropriate message and signs it with his private key he generated in the first step.
Then, he adds his public key from the first step and the unblinded signature from the third step to the message.
The whole message is then posted to a public space that abides by the criteria outlined earlier.
\end{enumerate}


\subsection{Assembling User Intent Messages}


\subsection{Time Stamping User Intent Messages}


% OBTAIN PP:
% PP_1 := (IDPUBKEY) (TYPE) (SCOPE) 
% SIG_1 := RSA_ENCRYPT(BLINDPRIVKEY, HASH(PP_1))
% SIG_2 := RSA_ENCRYPT(CTAPRIVKEY(SCOPE), SIG_1)
% SIG := RSA_DECRYPT(BLINDPUBKEY, SIG_2)
% PP := (PP_1) (SIG)
%
% ASSEMBLE MSG:
% HDID := RSA_ENCRYPT(REVPRIVKEY(PP, SEQ), HASH(DID))
% HUIC := RSA_ENCRYPT(REVPRIVKEY(PP, SEQ), HASH(UIC))
% MSG_1 := (PP) (SEQ) [(HDID)] (HUIC) (TS)
% POO := RSA_ENCRYPT(IDPRIVKEY, HASH(MSG_1))
% MSG := (MSG_1) (POO)
%
% ASSEMBLE REVEAL MSG:
% RMSG_1 := (PP) (SEQ) (REVPUBKEY(PP, SEQ)) [(RDID)] (RUIC) (TS)
% POO := RSA_ENCRYPT(IDPRIVKEY, HASH(RMSG_1))
% RMSG := (RMSG) (POO) 
%
% TIMESTAMP MSG: 
% H := HASH(MSG)
% TSP := RSA_ENCRYPT(CTAPRIVKEY(SCOPE), HASH((H)(CTATS)))
% MSG := (MSG) (TSP)
%
% CHECK POO:
% RSA_DECRYPT(IDPUBKEY, POO) == HASH(MSG_1)
%
% CHECK TSP: (CTATS == TS)
% RSA_DECRYPT(CTAPUBKEY(SCOPE), TSP) == HASH(HASH(MSG), TS) && TS IN PERIOD(SCOPE)
%
% CHECK TSP OF REVEAL:
% RSA_DECRYPT(CTAPUBKEY(SCOPE), TSP) == HASH(HASH(MSG), TS) && TS > PERIOD(SCOPE)
%
% CHECK REVEAL VALIDITY:
% RSA_DECRYPT(REVPUBKEY(PP, SEQ), HDID) == HASH(RDID) &&
% RSA_DECRYPT(REVPUBKEY(PP, SEQ), HUIC) == HASH(RUIC)

\todo{@KD: digest notes to text}

\section{Vote Tallying Protocol}
\label{sec:VoteTallyingProtocol}
The vote tallying protocoll describes the steps necessary to carry out vote tallying in the public space for some proposition after its voting phase has ended.
It can be implemented as part of a vote(-delegation) client, as a public service and directly within the platform.
The idea is that everyone is able to carry out the vote tallying process purely relying on public, signed data.
As counting support scores and counting votes have merely semantical differences, for sake of brevity we chose to only describe the vote counting process here:

\begin{enumerate}
  \item For a given proposition group $p$, collect all user intents from the public space
  \item Build the delegation graph $\mathcal{D}$ from the delegation intents
  \item Invert all edges in $\mathcal{D}$ to obtain $\mathcal{D}^I$\footnote{Replace all directed edges $(u,v)$ by edges $(v,u)$, $u,v \in N, (u,v) \in E$, with $D=(N,E)$}
  \item All vote intents are collected in a list $V$
  \item If $V$ is not exhausted, assign the next vote intent in $V$ to $v$, else terminate
  \item Check $v$ against the central trusted authority for validity 
  \item If $v$ is not valid, return to number 5
  \item Initialize the voting power $p_v$ of $v$ to 1
  \item If $\mathcal{D}^I$ does not contain $v$, advance to number 13
  \item Remove all incoming edges of $v$ in $\mathcal{D}^I$
  \item Find all nodes $S$ in $\mathcal{D}^I$ that are reachable from $v$
  \item Set $p_v$ to $|S|+1$
  \item In the voting protocol, add $p_v$ to the vote count for the voting option that $v$ voted for
  \item Return to number 5
\end{enumerate}


%\section{Demo Application}
%\label{ssec:DemoApplication}
