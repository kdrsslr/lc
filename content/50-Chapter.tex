\chapter{Our Project â€” Liquid Democracy Index Game}
\label{ch:ProjectRequirements}


This section will describe the process of developing a prototype for a Citizen Science-focused Liquid Democracy game, based on the \href{sec:Approach}{discussion of the approach} to fulfill the objective of this project, and due to the \href{sec:DiscussionRW}{fact} that no suitable software exists to base the prototype on, this section will document the software development process we took to develop said prototype.

Based on mentioned \href{sec:Criteria}{criteria} and an \href{sec:AnalysisProcesses}{analysis of the processes} for a system for Liquid Democracy, we will \href{sec:SoftwareRequirements}{derive software requirements} the prototype needs to fulfill, before describing the \href{sec:Implementation}{process of implementing} said prototype. Since we base our prototype on a modular architecture around microservices, we will focus predominantly on the \href{ssec:Architecture}{architecture} of the prototype, as well as the implemented \href{ssec:Microservices}{micro services} and the (functional) \href{ssec:Modules}{modules} integrating the respective processes. The last part of this chapter \href{ssec:VotingProtocol}{describes the public interaction protocol} that should be implemented by clients in order to post their vote or delegation intents to the public space.

\section{Requirements for the Prototype}
\label{sec:SoftwareRequirements}
\section{Prototype Implementation}
\label{sec:Implementation}

As highlighted in the discussion above, we aimed for a software design that allowed for flexibility, incorporating multiple contexts and a decentralized application context / paradigm. Because of this we chose an approach centered around microservices and (as far as possible) independent modules. Since we want it to be available for many different contexts, we focus on the mechanisms and provide an architecture where the users are independent from the servers offering the services as well as the frontend. For the same reason we also don't offer a frontend solution going beyond a testing environment for the implemented mechanisms, and leave the implementation of fullgrown UIs to designers of applications of the software.

\subsection{Architecture}
\label{ssec:Architecture}
As mentioned in the introduction of this section, the system architecture of Liquid Citizen is highly decentralized and modular. Different components are realized self-sufficiently, with their own APIs, in their own docker containers, and are developed in their respective \href{https://github.com/Liquid-Citizen}{github repositories}. Since the different components operate on distinct ports, they can be run on the same machine; However, to be true to the decentralized standard of the system, they can run on different machines just as well. Thus their development as well as their production is entirely encapsulated within itself.

Since the components however form a service ecosystem where the different components need to interact / exchange data with one another, care needs to be taken to integrate the components well with one another, which violates their independence, but is needed for functionality. These aspects will be discussed in the following, in the \hyperref[ssec:Microservices]{description of the microservices}. The respective components, as modules of the software, are sketched \hyperref[ssec:Modules]{afterwards}.

% We need layers to draw the block diagram
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

% Define a few styles and constants
\tikzstyle{insideBlock}=[draw, fill=white!20, text width=5em, 
    text centered, minimum height=2.5em]
\tikzstyle{layer} = [insideBlock, text width=6em, fill=white!20, 
    minimum height=20em, rounded corners]
\def\blockdist{2.3}
\def\edgedist{2.5}

\begin{tikzpicture}
    
    % Note the use of \path instead of \node at ... below. 
    \draw node (c1) [insideBlock] {Client (user)};
%     \path (clientLayerBlock.-150)+(-\blockdist,0) node (c2) [insideBlock] {Client (user)};
%     \path (clientLayerBlock.430)+(-\blockdist,0) node (cn) [insideBlock] {Client / user};
	\path node [below=1em of c1] (c2) [insideBlock] {Client (user)};
	\path node [below=3em of c2] (cn) [insideBlock] {Client (user)};
    \path (c2) -- node (dotdot) {\vdots} (cn);
    \draw node [layer, right=5em of dotdot] (serviceLayer) {Service layer};
    % Unfortunately we cant use the convenient \path (fromnode) -- (tonode) 
    % syntax here. This is because TikZ draws the path from the node centers
    % and clip the path at the node boundaries. We want horizontal lines, but
    % the sensor and naveq blocks aren't aligned horizontally. Instead we use
    % the line intersection syntax |- to calculate the correct coordinate
    \path [draw, ->] (c1) -- node [above] {}
        (serviceLayer.west |- c1) ;
    % We could simply have written (gyros) .. (naveq.140). However, it's
    % best to avoid hard coding coordinates
    \path [draw, ->] (c2) -- node [above] {}
        (serviceLayer.west |- c2);
    \path [draw, ->] (cn) -- node [above] {}
        (serviceLayer.west |- cn);
    \node (clientLayerLabel) [below=1em of cn,align=center] {Client layer \\ (users)};
    
    % Now it's time to draw the colored IMU and INS rectangles.
    % To draw them behind the blocks we use pgf layers. This way we  
    % can use the above block coordinates to place the backgrounds   
    \begin{pgfonlayer}{background}
        % Compute a few helper coordinates
        \path (c1.west |- serviceLayer.north)+(-0.7,0.5) node (a) {};
        \path (c1.north west)+(-0.3,0.3) node (a) {};
        \path (clientLayerLabel.south -| c1.east)+(+0.4,-0.4) node (b) {};
        \path[fill=white!10,rounded corners, draw=black!50, dashed]
            (a) rectangle (b);
    \end{pgfonlayer}
\end{tikzpicture}

\subsection{Microservices}
\label{ssec:Microservices}

\subsubsection{Vote Authentication Service}
The vote authentication server administrates the vote tokens, enabling users to vote on propositions. It keeps a list of all vote-tokens issued, with an association pf the delegation tokens used to request them for each proposition in a voting phase. It further offers the functionality to calculate the value of a vote token (after a voting phase has finished).

\subsubsection{Delegation Service}
The delegation service serves two goals dependent goals. For one, it is responsible for storing the vote delegations (per proposition / context) and for managing delegation tokens. These services can't modeled independently since the value of a delegation token depends on the state of the delegation graph / table (and whether delegation tokens were issued to the respective delegators), which justifies why they are encapsulated in the same service.
% * <johanning@informatik.uni-leipzig.de> 2018-02-12T16:55:52.982Z:
% 
% > These services can't modeled independently since the value of a delegation token depends on the state of the delegation graph / table
% This can be done through an (internal) API; However would we want to expose such sensitive data to an API (even if it needs authentication of the delegation token service)?
% 
% 
% ^.
The services are designed as follows:

\paragraph*{Vote Delegation} \mbox{} \\
Vote delegation is the transfer of voting rights on a proposition or a context from a delegator to a delegate. For votes delegated for a context, voting rights are delegated for all subcontexts and proposition falling under it. If vote delegations are represented as a (delegation) graph, conceptually this means inserting an edge from the delegator to the delegate; This could just as well be represented as adding an association of the delegated proposition and context with the delegate.
% * <johanning@informatik.uni-leipzig.de> 2018-02-13T10:17:51.591Z:
% 
% >  If vote delegations are represented as a (delegation) graph, conceptually this means inserting an edge from the delegator to the delegate; This could just as well be represented as adding an association of the delegated proposition and context with the delegate.
% 
% too much implementation details for design?
% 
% ^.
Voting right delegation for propositions and subcontexts takes precedence over delegation for contexts. Thus if a delegator $A$ delegates their voting rights to a delegate $D$ for a context $C$ , and withdraws it (or re-delegates it to $D'$) for a subcontext $C'$ or a proposition $P$ , for voting on $P$ or a proposition falling under $C'$ , the vote of $A$ (or $D'$ ) counts (and the vote of $D$ is disregarded).

The functionality described above means that the vote delegation has to provide an interface which allows to add, as well as remove a vote delegation, either for a proposition or a context. It further needs to provide functionality to determine if / to whom voting right was delegated for a given proposition. This will be determined by checking if voting right for the proposition was explicitly transfered, and if not, it will 'move up the supercontext chain' until a delegated context was found, which will count as the vote delegation. Since a (sub-) context  can not have multiple supercontexts, this is always unambiguous.

\paragraph*{Delegation Token Handling} \mbox{} \\


\subsection{Modules}
% * <johanning@informatik.uni-leipzig.de> 2018-02-12T15:35:03.065Z:
% 
% > Microservices}
% > \label{ssec:Microservices}
% > \subsubsection{vote authentication server}
% > The vote authentication server administrates the vote tokens, enabling users to vote on propositions. It keeps a list of all vote-tokens issued, 
% > \subsection{Modules}
% 
% How do we define microservices, how modules? What are the differences (conceptually and in our case)?
% 
% ^ <johanning@informatik.uni-leipzig.de> 2018-02-12T16:44:24.561Z:
% 
% A websearch on modules vs. microservices mostly resulted in a discussion of modular approach in monolith application (as in easier type conversions, easier to develop within an existing organization etc.) vs microservices (as services that can employ different technology stacks and can be deployed changed easier (which also was contended). It is pretty clear where we stand, but I think that we meant something else with modules (namely in more functional terms); I'm just not so sure anymore how we meant it / how it makes sense. Maybe scrap the modules part and write the microservice part from a higher level perspective and then be more concrete (i.e. document the individual microservice) in the implementation part?
%
% ^.
% * <kvndrsslr@gmail.com> 2018-07-24T13:38:27.037Z:
% 
% I am in favour of
% *  dropping the modules section 
% * high level description of microservices in microservices, detailed in seperate sections
% * new subsection after microservices: public interaction protocol. Here we should introduce the need of a formal protocol when posting to the public space. maybe go into detail in seperate section
% * new subsection after public interaction protocol: vote tallying  protocol. Here we describe the process / algorithm that clients need to implement in order to tally votes.
% * new subsection after vote tallying  protocol: application demo.  Here we should comment on how we implemented the application demo, which is a module that emulates user action, interacts with the microservices and uses the public interaction protocol to post to the public space. 
% 
% ^.

\label{ssec:Modules}
This subsection will give a brief overview of the different modules within the service ecosystem. The different modules themselves are described in their respective sections later in this chapter; This subsection will give a course overview of the different modules.

% \paragraph{Voting Module} \mbox{} \\
% The \textbf{voting module} implements the process of vote casting on propositions in the voting phase. Through this, users that didn't delegate their vote for the respective proposition or a respective context, can cast their vote using a (vote-specific) vote token.
% In this it interacts with the proposition, the authentication, the delegation and the user module. It is described in detail in \ref{sec:Implementation_Voting}.

% \section{Implementation of the Voting Mechanism}
% \label{sec:Implementation_Voting}


% \subsection{Vote Authentication Service}
% The API of the VAS offers the following HTTP-request handling:

% \paragraph*{POST: registerForVote(propositionID, delegationToken, OTS)}
% Registers the given delegationToken to participate in the vote for a given proposition.
% Will create a voteToken and a VASpoo (VAS proof-of-ownership), and an entry in the respective table (associated with propID) with an association of the voteToken, the VASpoo and the delegationToken.
% Returns a pair (VT, VASpoo), encrypted by the one-time-secret provided in the API call.

% \paragraph*{POST: evaluateVote(voteToken, SLO, propID)} \mbox{} \\
% Prepares a vote for a given proposition for vote counting by determining the optionToken and votePowerToken, so the calling entity can determine the semantics of the vote within the vote counting.
% Returns a pair (O, vpt) of the optionToken and the votePowerToken, that can be evaluated through the propositionService and the VDS in order to evaluate the vote.
% It will call the evaluateVote operation of the VAS with the respective delegationToken, second-layer-optionToken (SLO) and propID, deriving the first-layer-optionToken (FLO) and the vtp. It then derives the option from the FLO by decrypting it with the corresponding VASpoo.

% Returns respective errors, as well as when voteToken doesn't exist

% \paragraph*{Data base structure VAS} \mbox{} \\
% The VAS stores the data associated with the voteTokens for the respective propositions. It features a table for each proposition with the following columns:
%  - voteToken: String
%  - delegationToken: String
%  - VASpoo: String

% \section{Implementation of the Delegation Mechanism}

% \subsection{Vote Delegation Server}

% \paragraph*{POST: createDelegationToken(propositionID, userID, OTS)} \mbox{} \\

% Creates an entry in the proposition table corresponding to the propositionID, associating the userID, delegationToken and a VDSpoo (VDS delegation token proof-of-ownership) and returns the respective pair.

% \paragraph*{POST: evaluateDelegationToken(propositionID, delegationToken, SLO)} \mbox{} \\

% Operation that prepares the evaluation of a delegation token for the respective proposition. Will create a token based on the SLO in order to determine the value of the vote (votes delegated to the user with this DT). Also decrypts the SLO to the corresponding FLO based on the VDSpoo associated with the delegationToken.
% Returns the pair (FLO, vpt) with the optionToken encrypted by the VASpoo (as the SLO decrypted by the VDSpoo) and the votePowerToken used to evaluate the voting power of the delegationToken.

% The value of the vote (vpt) is determined by deriving the number of users delegating the voting power to the user associated with the delegationToken for the given proposition (either directly as a delegation for the proposition, or of a context / supercontext of the proposition, if no other exists) at the time of vote closing, as long as they didn't possess a valid delegationToken for this proposition. 

% \paragraph*{POST: revokeDelegationToken(propID, delegationToken, pooUserToken} \mbox{} \\
% Revokes the delegationToken provided, making it invalid for the vote on the given proposition, so that the delegation by the user is counted. Requires the parameters of the proposition ID the DT was issue for, the DT to revoke, and a token created by encrypting the anonToken of the requesting user with the VDSpoo of the respective token.
% The validity of the request is determined by decrypting the pooUserToken with the VDSpoo associated with the delegationToken and checking whether its the anonToken associated with the DT provided in the request.

% \paragraph*{POST: delegateProposition(propID, delegatingUser, delegate} \mbox{} \\
% Delegates the voting power on a given proposition from the delegatingUser to the delegate. Basically inserts an edge of the type / label of the propositionID into the delegation graph (at the current time of the VDS). Revokes earlier delegations for this proposition if necessary.

% \paragraph*{POST: delegateContext(context, delegatingUser, delegate} \mbox{} \\
% Delegates the voting power on a given context from the delegatingUser to the delegate. Basically inserts an edge of the type / label of the context into the delegation graph (at the current time of the VDS). Revokes earlier delegations for this context if necessary. 
% Will be revoked if all subcontexts are already delegated to other users.

% \paragraph*{GET: deriveLogicalGraph(graphOperation} \mbox{} \\
% Performs a graphOperation (read-only) on the delegation graph as long as this operation is not forbidden.
% graphOperation needs to be a string representing a valid operation for the underlying graph database.

% \paragraph*{POST: determineVotePower(vpt, SLO} \mbox{} \\
% Operation to determine whether a votePowerToken issued is valid, and if so how much voting power is associated with it (given the state of the delegationGraph at the expiration of the voting phase of the proposition, given the second-layer-option SLO. Is used to determine whether data was manipulated within the vote evaluation process by the VAS, and how much it is worth. Will check whether the vpt is associated with the SLO (i.e. the pair is valid), and if so return the respective value.

% \paragraph*{Data base structure VDS} \mbox{} \\
% The VDS stores the data associated with the delegationTokens for the respective propositions. It features a table for each proposition with the following columns:
%  - userID: String
%  - delegationToken: String
%  - VDSpoo: String

% \subsection{Proposition Server}

% \paragraph*{POST: createProposition()} \mbox{} \\
% Creates a new proposition according to the parameters transmitted, as well as the proposition group alternative propositions to the newly created proposition will belong to.

% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.

% \paragraph*{POST: createAlternativeProposition(propositionGroupID)} \mbox{} \\
% Creates a new alternative proposition belonging to the propositionGroupID of the referred proposition.

% Transmitted parameters conflicting with the proposition configuration of the proposition service will be ignored.

% \paragraph*{POST: createPropositionToken(propositionID,plainTextOption)} \mbox{} \\
% Creates a propositionToken for the respective proposition, associated with the respective plainTextOption (as long as the proposition and the option exists). The propositionToken can be used to derive the plainTextOption associated with it, and is introduced so the plainTextOption can't be manipulated by other actors in the vote evaluation process.

% \paragraph*{POST: derivePlainTextOption(propositionToken)} \mbox{} \\
% Returns the plain text option associated with the proposition token.


% \paragraph*{GET: getPropositionInformation(propositionID, foobar)} \mbox{} \\
% Will return relevant information about the proposition in question.

% \paragraph*{GET: getPropositionVoteClosingTime(propositionID)} \mbox{} \\
% Returns the vote closing time of the proposition (when the voting period ended).

% \paragraph*{GET: getPropositionVoteOpeningTime(propositionID)} \mbox{} \\
% Returns the vote opening time of the proposition (when the voting period started).

% \paragraph*{POST: signVote(vote)} \mbox{} \\
% Signs a vote with the current time stamp to prove that the vote was casted on time. 

% \paragraph*{Data base structure proposition service} \mbox{} \\
% The proposition service stores the data for the propositions as well as the proposition tokens used for vote casting. For this it features two tables, one with the proposition data (to be specified) and one with a mapping of the optionTokens and the respective plainTextOptions.


\subsection{Public Interaction Protocol}
\label{ssec:VotingProtocol}